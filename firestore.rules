rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Fonction utilitaire pour vérifier si l'utilisateur est un administrateur
    function isAdmin() {
      // ASSUREZ-VOUS DE REMPLACER PAR L'UID RÉEL DE L'ADMINISTRATEUR
      return request.auth != null && request.auth.uid == '4aqCNYkLwgXpp5kjMnGA6V0bdL52';
    }

    // Règle pour la collection "parties" (Événements)
    match /parties/{partyId} {
      allow read: if true; // Ou request.auth != null; si non public

      allow create: if request.auth != null &&
                       request.resource.data.name is string &&
                       request.resource.data.name.size() > 0 &&
                       request.resource.data.date is timestamp &&
                       request.resource.data.createdBy == request.auth.uid &&
                       request.resource.data.creatorEmail == request.auth.token.email &&
                       request.resource.data.participants is list &&
                       request.auth.uid in request.resource.data.participants;

      allow update: if request.auth != null &&
                      (
                        // Règle 1: Créateur ou Admin met à jour les détails principaux ET/OU les mediaItems ET/OU les participants
                        ( (request.auth.uid == resource.data.createdBy || isAdmin()) &&
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['name', 'description', 'date', 'location', 'coverPhotoUrl', 'latitude', 'longitude', 'participants', 'participantEmails', 'mediaItems']) &&
                          // Validations pour les champs mis à jour si présents (simplifié)
                          (!('name' in request.resource.data.diff(resource.data).affectedKeys()) || (request.resource.data.name is string && request.resource.data.name.size() > 0) ) &&
                          (!('date' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.date is timestamp ) &&
                          // Empêcher la modification des champs sensibles par cette voie
                          request.resource.data.createdBy == resource.data.createdBy &&
                          request.resource.data.creatorEmail == resource.data.creatorEmail
                        ) ||
                        // Règle 2: Tout utilisateur connecté peut ajouter/mettre à jour SA PROPRE note
                        (
                          // L'opération de mise à jour au niveau du document ne doit affecter que le champ 'ratings'.
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['ratings']) &&
                          // La clé spécifique dans la map 'ratings' qui est ajoutée/modifiée est bien celle de l'utilisateur authentifié.
                          (request.auth.uid in request.resource.data.ratings.keys()) &&
                          // La nouvelle valeur de la note est un nombre entre 0 et 10.
                          request.resource.data.ratings[request.auth.uid] is number &&
                          request.resource.data.ratings[request.auth.uid] >= 0 &&
                          request.resource.data.ratings[request.auth.uid] <= 10 &&
                          // Assurer que les notes des autres utilisateurs restent inchangées et qu'aucune nouvelle note pour d'autres utilisateurs n'est ajoutée.
                          // 1. Toutes les clés qui existaient dans `resource.data.ratings` (avant la mise à jour)
                          //    doivent exister dans `request.resource.data.ratings` (après la mise à jour)
                          //    AVEC LA MÊME VALEUR, SAUF si la clé est celle de l'utilisateur actuel.
                          (forall keyInOldRatings in resource.data.ratings.keys():
                            keyInOldRatings == request.auth.uid || // La note de l'utilisateur actuel peut changer
                            (keyInOldRatings in request.resource.data.ratings.keys() &&  // La clé doit toujours exister
                             resource.data.ratings[keyInOldRatings] == request.resource.data.ratings[keyInOldRatings]) // Et sa valeur doit être la même
                          ) &&
                          // 2. Toutes les clés dans `request.resource.data.ratings` (après la mise à jour)
                          //    devaient exister dans `resource.data.ratings` (avant la mise à jour),
                          //    SAUF si la clé est celle de l'utilisateur actuel (qui pourrait être une nouvelle note).
                          (forall keyInNewRatings in request.resource.data.ratings.keys():
                            keyInNewRatings == request.auth.uid || // C'est la note de l'utilisateur actuel (nouvelle ou modifiée)
                            keyInNewRatings in resource.data.ratings.keys() // Ou la clé existait déjà
                          )
                        ) ||
                        // Règle 3: Tout utilisateur connecté peut AJOUTER des souvenirs (mediaItems)
                        (
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['mediaItems']) &&
                          request.resource.data.mediaItems.size() > resource.data.mediaItems.size() && // Strictement pour l'ajout
                          (request.resource.data.mediaItems[request.resource.data.mediaItems.size() - 1] is map && // Le nouvel item est une map
                           request.resource.data.mediaItems[request.resource.data.mediaItems.size() - 1].uploaderId == request.auth.uid) // L'uploaderId correspond
                        )
                      );

      allow delete: if isAdmin();

      match /comments/{commentId} {
        allow read: if true; // Ou request.auth != null;

        allow create: if request.auth != null &&
                         request.resource.data.userId == request.auth.uid &&
                         request.resource.data.text is string &&
                         request.resource.data.text.size() > 0 &&
                         request.resource.data.partyId == partyId &&
                         request.resource.data.timestamp is timestamp;

        allow update: if request.auth != null &&
                         (
                           (request.auth.uid == resource.data.userId &&
                            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text']) &&
                            request.resource.data.text is string && request.resource.data.text.size() > 0 &&
                            request.resource.data.userId == resource.data.userId &&
                            request.resource.data.partyId == resource.data.partyId &&
                            request.resource.data.timestamp == resource.data.timestamp
                           ) ||
                           isAdmin()
                         );

        allow delete: if request.auth != null &&
                         (request.auth.uid == resource.data.userId || isAdmin());
      }
    }

    match /users/{userId} {
      allow read: if true;
      allow create: if request.auth != null &&
                       request.auth.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       request.resource.data.uid == request.auth.uid &&
                       request.resource.data.createdAt is timestamp;

      allow update: if request.auth != null &&
                       (
                         ( request.auth.uid == userId &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['displayName', 'pseudo', 'avatarUrl']) &&
                           (!('displayName' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.displayName is string) &&
                           (!('pseudo' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.pseudo is string) &&
                           (!('avatarUrl' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.avatarUrl is string)
                         ) ||
                         isAdmin()
                       ) &&
                       (isAdmin() || (
                           request.resource.data.uid == resource.data.uid &&
                           request.resource.data.email == resource.data.email &&
                           request.resource.data.createdAt == resource.data.createdAt
                       ));

      allow delete: if isAdmin();
    }
  }
}
